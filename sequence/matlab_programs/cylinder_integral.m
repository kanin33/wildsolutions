function [M] = cylinder_integral2(vars_k, v_tilde)
    % vars    = [r, t, x, y, p0, p1, p2, p3, N, eta1, eta2, eta3, a1, a2, b2, b3, lambda]
    % v_tilde = [v_tilde0, v_tilde1]

    rmax = 1; thetamax = 2*pi; tmin = -1; tmax = 1;
    r     = chebfun3(@(r,theta,t) r,     [0 rmax 0 thetamax tmin tmax], 'vectorize', 'eps', 1e-3);
    theta = chebfun3(@(r,theta,t) theta, [0 rmax 0 thetamax tmin tmax], 'vectorize', 'eps', 1e-3);
    t     = chebfun3(@(r,theta,t) t,     [0 rmax 0 thetamax tmin tmax], 'vectorize', 'eps', 1e-3);
    x     = r.*cos(theta);
    y     = r.*sin(theta);

    % Manually set number of working cores
    %parpool('local',2)

    % Compute
    % sum_i=1^allpoints ( iiint (2v_tilde v_i) dx1 dx2 dt
    %                     + sum_j=1^allpoints ( iiint (v_i v_j) dx1 dx2 dt )
    
    M = 0; % Integral
    parfor i=1:size(vars_k,2)
        r1i  = vars_k(1,i);
        t_ji = vars_k(2,i);
        x_ji = vars_k(3,i);
        y_ji = vars_k(4,i);
        p0i  = vars_k(5,i);
        p1i  = vars_k(6,i);
        p2i  = vars_k(7,i);
        p3i  = vars_k(8,i);
        Ni   = vars_k(9,i);
        eta1i = vars_k(10,i);
        eta2i = vars_k(11,i);
        eta3i = vars_k(12,i);
        a1i   = vars_k(13,i);
        a2i   = vars_k(14,i);
        b1i   = vars_k(15,i);
        b2i   = vars_k(16,i);
        lambdai = vars_k(17,i);
        ampli = vars_k(18,i);

        a1 = chebfun3(@(r, theta, t) v1(t*r1i + t_ji, ...
                                        r.*cos(theta)*r1i + x_ji, ...
                                        r.*sin(theta)*r1i + y_ji, ...
                                        r1i, t_ji, x_ji, y_ji, ...
                                        p0i, p1i, p2i, p3i, Ni, ...
                                        eta1i, eta2i, eta3i, ...
                                        a1i, a2i, b1i, b2i, ...
                                        lambdai, ampli).*r, ...
                    [0 rmax 0 thetamax tmin tmax], ...
                    'vectorize', ...
                    'eps', 1e-5, ...
                    'splitting','on');

        a2 = chebfun3(@(r, theta, t) v2(t*r1i + t_ji, ...
                                        r.*cos(theta)*r1i + x_ji, ...
                                        r.*sin(theta)*r1i + y_ji, ...
                                        r1i, t_ji, x_ji, y_ji, ...
                                        p0i, p1i, p2i, p3i, Ni, ...
                                        eta1i, eta2i, eta3i, ...
                                        a1i, a2i, b1i, b2i, ...
                                        lambdai, ampli).*r, ...
                    [0 rmax 0 thetamax tmin tmax], ...
                    'vectorize', ...
                    'eps', 1e-5, ...
                    'splitting','on');

        I = 2*v_tilde(1).*integral3(a1) + 2*v_tilde(2).*integral3(a2);
        M = M + r1i.^3.*I;
        
        for j=1:size(vars_k,2)
            r1j  = vars_k(1,j);
            t_jj = vars_k(2,j);
            x_jj = vars_k(3,j);
            y_jj = vars_k(4,j);
            p0j  = vars_k(5,j);
            p1j  = vars_k(6,j);
            p2j  = vars_k(7,j);
            p3j  = vars_k(8,j);
            Nj   = vars_k(9,j);
            eta1j = vars_k(10,j);
            eta2j = vars_k(11,j);
            eta3j = vars_k(12,j);
            a1j = vars_k(13,j);
            a2j = vars_k(14,j);
            b1j = vars_k(15,j);
            b2j = vars_k(16,j);
            lambdaj = vars_k(17,j);
            amplj = vars_k(18,j);

            % check if supp(vi) \cap supp(vj) is empty
            l = sqrt((t_ji - t_jj)^2 + (x_ji - x_jj)^2 + (y_ji - y_jj)^2);
            if l < r1i + r1j
                if r1i > r1j
                    r1 = r1j;
                    x_j = x_jj;
                    y_j = y_jj;
                    t_j = t_jj;
                else
                    r1 = r1i;
                    x_j = x_ji;
                    y_j = y_ji;
                    t_j = t_jj;
                end
                a11 = chebfun3(@(r, theta, t) v1(t*r1 + t_j,          ...
                                               r.*cos(theta)*r1 + x_j,  ...
                                               r.*sin(theta)*r1 + y_j,  ...
                                               r1i, t_ji, x_ji, y_ji,   ...
                                               p0i, p1i, p2i, p3i,      ...
                                               Ni, eta1i, eta2i, eta3i, ...
                                               a1i, a2i, b1i, b2i,      ...
                                               lambdai, amplj) ...
                                            *v1(t*r1 + t_j,         ...
                                               r.*cos(theta)*r1 + x_j,  ...
                                               r.*sin(theta)*r1 + y_j,  ...
                                               r1j, t_jj, x_jj, y_jj,   ...
                                               p0j, p1j, p2j, p3j,      ...
                                               Nj, eta1j, eta2j, eta3j, ...
                                               a1j, a2j, b1j, b2j,      ...
                                               lambdaj, amplj).*r, ...
                        [0 rmax 0 thetamax tmin tmax], ...
                        'vectorize', ...
                        'eps', 1e-5, ...
                        'splitting','on');

                 a12 = chebfun3(@(r, theta, t) v2(t*r1 + t_j,          ...
                                               r.*cos(theta)*r1 + x_j,  ...
                                               r.*sin(theta)*r1 + y_j,  ...
                                               r1i, t_ji, x_ji, y_ji,   ...
                                               p0i, p1i, p2i, p3i,      ...
                                               Ni, eta1i, eta2i, eta3i, ...
                                               a1i, a2i, b1i, b2i,      ...
                                               lambdai, amplj) ...
                                            *v2(t*r1 + t_j,         ...
                                               r.*cos(theta)*r1 + x_j,  ...
                                               r.*sin(theta)*r1 + y_j,  ...
                                               r1j, t_jj, x_jj, y_jj,   ...
                                               p0j, p1j, p2j, p3j,      ...
                                               Nj, eta1j, eta2j, eta3j, ...
                                               a1j, a2j, b1j, b2j,      ...
                                               lambdaj, amplj).*r, ...
                        [0 rmax 0 thetamax tmin tmax], ...
                        'vectorize', ...
                        'eps', 1e-5, ...
                        'splitting','on');
                I = integral3(a11) + integral3(a12);
                M = M + r1.^3.*I;
            end
        end
    end
